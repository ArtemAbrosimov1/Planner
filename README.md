# Planner

Это учебный проект в рамках дисциплины "Конструирование программного обеспечения". Задача этого проекта в первую очередь - пройти большинство классических стадий создания ПО, а уже во вторую очередь - создать приложение-Planner.

## Тема проекта: 
"Создание мобильного приложения, реализующего планнер с интеграцией учебного расписания".

## Состав группы:
- Абросимов Артем Дмитриевич 5130904/30107
- Байкин Кирилл Александрович 5130904/30107
- Калашникова Полина Олеговна 5130904/30107
- Марков Леонид Александрович 5130904/30107

## Технологический стек:
Android Studio, Kotlin, Jetpack Compose, PostgreSQL, GitHub, API расписания СПБПУ

## Определение проблемы:
На рынке приложений-планеров не существует продукта, реализующего удобную синхронизацию между учебным расписанием и повседневными задачами, соединяющего всю информацию об учебных и внеучебных активностях вуза, с возможностью установки на определенное время PUSH-уведомлений.

## Выработка требований:
- Как студент Политеха, я хочу иметь возможность синхронизации учебного расписания с повседневными задачами, чтобы планировать весь свой день в одном приложении.
- Как студент Политеха, я хочу всегда быть в курсе проходящих в стенах моего вуза событий, чтобы активно участвовать в жизни института.

## Разработка архитектуры и детальное проектирование:


- **Характер нагрузки на сервис:**
  <details>
  <summary><strong>Соотношение R/W нагрузки:</strong></summary>
    
    ```
    Нагрузка не будет равномерно распределена в течение суток. Явные пики будут возникать:
    - Утром (перед началом пар)
    - В начале недели (понедельник)
    
    **Операция при запуске приложения:**
    - **Чтение (R):** Сервис должен прочитать из базы данных номер академической группы.
    - **Запись (W):** Сервис делает запрос к внешнему API, получает расписание для этой группы и записывает его в базе данных.
    - **Чтение (R):** Приложение читает свежее расписание из БД и показывает пользователю.
    
    **Вывод:** На один запуск приложения приходится как минимум 2 операции чтения и 1 операция записи — 2:1 в пользу чтения.
    ```
    </details>
    
  <details>
  <summary><strong>Объемы трафика:</strong></summary>

    ```
    Пиковая нагрузка — 10 000 пользователей в сутки.
    Допустим, 70% всех запусков (7000) происходит за 2 пиковых часа (7200 секунд). Тогда пиковый RPS = 7000 / 7200 ~1 RPS. Это очень низкий показатель. 
    В реальности пик может быть короче. Допустим, 1000 пользователей запустят приложение за 5 минут (300 секунд) перед первой парой. Тогда пиковый RPS = 1000 / 300 ~3.3 RPS. 

    **Расчет объема данных:**
    Основной объем — это отдача расписания (~20 КБ на запрос). Пиковый исходящий трафик: 3.3 RPS * 20 КБ ~ 66 КБ/с ~ 0.5 Мбит/с. Это ничтожно мало.

    **Вывод:** Сетевой трафик для такого сервиса минимален и не является узким местом.
    ```
    </details>
    
  <details>
  <summary><strong>Объемы дисковой системы:</strong></summary>

    ```
    Ключевой объект для хранения — база данных пользователей. Примерно 100 байт на пользователя (4 байта int для id пользователя + 10 символов VARCHAR для номера академической группы + 50 байт закладываем запаса для персональных данных). Общий объем данных: 10 000 пользователей * 100 байт = 1 000 000 байт ≈ 1 MB. 

    **Вывод:** объем диска в гигабайтах (минимальный объем).
    ```
    </details>
    
- **Первые две диаграммы из подхода https://c4model.com/ :**

  https://www.figma.com/design/Y3a5ahYvWp8Ez3d0DZYniq/prj?node-id=6-135&t=22szgwyEt4IrPf0Y-1

- **Контракты API:**
  <details>
    
  - Получение списка институтов:

    - HTTP Method: **`GET`**
    - URL: **`https://ruz.spbstu.ru/api/v1/ruz/faculties`**
    - Path Params: -
    - Success response: `200`
    - Response format: **`JSON`**
    - Response example:
   
    ``` json
    {
     "faculties": [
      {
       "id": 121,
       "name": "Институт физической культуры, спорта и туризма",
       "abbr": "ИФКСиТ"
      },
      {
       "id": 123,
       "name": "Институт электроники и телекоммуникаций",
       "abbr": "ИЭиТ"
      }, {}
      ...
      ]
    }
    ```

  - Получение списка групп института

    - HTTP Method: **`GET`**
    - URL: **`https://ruz.spbstu.ru/api/v1/ruz/faculties/{faculty_id}/groups`**
    - Path Params: **`{faculty_id} - id института`**
    - Success response: `200`
    - Response format: **`JSON`**
    - Response example:
    ``` json
    {
     "groups": [
      {
       "id": 42817,
       "name": "5130203/20102",
       "level": 4,
       "type": "common",
       "kind": 0,
       "spec": "",
       "year": 2025
      },
      {
       "id": 42789,
       "name": "5130902/30202",
       "level": 3,
       "type": "common",
       "kind": 0,
       "spec": "",
       "year": 2025
      },
      ...
      ]
    }
    ```

  - Поиск группы по номеру

    - Назначение: Достать id группы
    - HTTP Method: **`GET`**
    - URL: **`https://ruz.spbstu.ru/api/v1/ruz/search/groups`**
    - Query Params: **`q - поисковая строка (например: ?q=5130904/30107)`**
    - Success response: `200`
    - Response format: **`JSON`**
    - Response example:
    ``` json
    {
     "groups": [
      {
       "id": 42799,
       "name": "5130904/30107",
       "level": 3,
       "type": "common",
       "kind": 0,
       "spec": "",
       "year": 2025,
       "faculty": {
        "id": 125,
        "name": "Институт компьютерных наук и кибербезопасности",
        "abbr": "ИКНК"
       }
      }
     ]
    }
    ```


  - Получение расписания на неделю

    - HTTP Method: **`GET`**
    - URL: **`https://ruz.spbstu.ru/api/v1/ruz/scheduler/{group_id}`**
    - Path Params: **`{group_id} - id группы`**
    - Query Params: **`date - опционально (в формате YYYY-MM-DD). Определяет неделю, в которую входит указанная дата и в качестве ответа отправляет расписание на эту неделю. Если не указана, возвращает расписание на текущую неделю.`**
    - Success response: `200`
    - Response format: **`JSON`**
    - Response example:
    ``` json
    {
     "week": {
      "date_start": "2025.09.15",
      "date_end": "2025.09.21",
      "is_odd": true
     },
     "days": [
      {
       "weekday": 1,
       "date": "2025-09-15",
       "lessons": [
        {
         "subject": "Архитектура программных систем",
         "subject_short": "Архитектура программных систем",
         "type": 0,
         "additional_info": "",
         "time_start": "10:00",
         "time_end": "11:40",
         "parity": 0,
         "typeObj": {
          "id": 27,
          "name": "Практика",
          "abbr": "Пр"
         },
         "groups": [
          **Перечисление групп в формате п. 3**
         ],
         "teachers": [
          {
           "id": 22154,
           "oid": 34639,
           "full_name": "Гончаров Александр Викторович",
           "first_name": "Гончаров",
           "middle_name": "Александр",
           "last_name": "Викторович",
           "grade": "",
           "chair": "51/03 Высшая школа программной инженерии"
          }
         ],
         "auditories": [
          {
           "id": 894,
           "name": "104",
           "building": {
            "id": 18,
            "name": "3-й учебный корпус",
            "abbr": "3 к.",
            "address": ""
           }
          }
         ],
         "webinar_url": "",
         "lms_url": "https://dl.spbstu.ru//course/view.php?id=7151"
        },
        {}, {} **Остальные занятия в этот день**
       ]
      },
      {}, {} **Остальные дни в этой неделе**
      ]
    }
    ```

  </details>
    
- **Ожидаемые нефункциональные требования на время отклика:**

  <details>
    
  Требования ко времени загрузки экрана UI:
  - Старт приложения с нуля < 1.5 секунд
  - Старт приложения из фона <0.5 секунд
  
  Требования к отзывчивости UI:
  - Все анимации и переходы между экранами должны быть плавными и стабильными, обеспечивая **60 FPS** на среднем по мощности устройстве. На устройствах низкого ценового сегмента допустимо кратковременное падение до 30 FPS в моменты пиковой нагрузки
  - Реакция на любое действие пользователя не должна превышать 100 мс
  
  Требования к запросам API:
  - Таймаут соединения - 3 секунды
  - Таймаут чтения - 5 секунд
  - Запросы на получение расписания обещают быть обработанными не более чем за 800 мс
  - Запросы на получение массивных списков - не более чем за 1200 мс
  
  Требования к работе с БД:
  - Время доступа к локальной БД не должно занимать больше 50 мс и производиться асинхронно, чтобы не замедлять работу UI потока.
  
  Данные требования на деле могут варьироваться в зависимости от устройства пользователя, доступности интернет соединения, нагрузки на сервера https://ruz.spbstu.ru ...

  </details>
  
- **Схема базы данных:**

  <details>
    
  Таблица ИНСТИТУТЫ с полями:
  - id (primary key)
  - name
  - abbr
  
  Таблица ГРУППЫ с полями:
  - id (primary key)
  - faculty_id (связь МНОГО-ОДИН из таблицы ИНСТИТУТЫ)
  - name
  
  Таблица РАСПИСАНИЕ с полями:
  - id (primary key - просто уникальный идентификатор занятия)
  - group_id (связь МНОГО-ОДИН из таблицы ГРУППЫ)
  - date
  - weekday (день недели от 1-пн до 6-суб)
  - subject
  - type (практика/лекция/лабораторная работа)
  - start_time
  - end_time
  - teacher
  - audithory
  
  Таблица ПОЛЬЗОВАТЕЛИ с полями:
  - id (primary key)
  - email
  - group_id
  - notifications_enabled
  - created_at
  - updated_at
  
  Таблица ЗАМЕТКИ ПОЛЬЗОВАТЕЛЯ с полями:
  - id (primary key)
  - user_id (связь МНОГО-ОДИН из таблицы ПОЛЬЗОВАТЕЛИ)
  - lesson_id (связь ОДИН-ОДИН из таблицы РАСПИСАНИЕ. Если это заметка к конкретной паре)
  - date (со временем, чтобы понимать куда это вставлять, если это заметка для окна или без привязки к паре/окну)
  - header
  - note
  - created_at
  - updated_at
  
  Таблица КЕШИРОВАНИЕ АПИ ВЫЗОВОВ с полями (для увеличения производительности):
  - id (primary key)
  - endpoint
  - params
  - responce (в формате JSON)
  - created_at
  - updated_at

  </details>
 
- **Почему она выдержит нефункциональные требования:**

  <details>

  В среднем у каждой группы ~4 пары в день (берем на вырост). Учебных дней - 6, значит пар в неделю - `6*4 = 24 штуки`. В год ~45 учебных недель, значит `24*45 = 1080 пар в год для одной группы`.
  Количество институтов  в Политехе - 16, групп в институте ~100, значит всего групп будет `16*100 = 1600 групп`, тогда пар для всего Политеха `1080*1600 = 1 728 000`
  
  Запись одной пары обойдется ~ в 200 байт, значит всего для хранения всех пар Политеха понадобится `1 728 000 * 200 = 0.3 ГБ`
  
  Добавим сюда пользовательские заметки:
  Будем считать ~5 заметок на каждый день (опять же берем с запасом). Количество пользователей будет составлять ~10000. Следовательно умножим количество учебных дней в году на количество заметок и на количество пользователей: `5*200*10000 = 10 000 000 записей`. 
  Тогда с учетом среднего размера в 500 байт, получится `10 000 000 * 500 = 4.66 ГБ`
  
  ИТОГО: вся база данных будет занимать всего около 5 ГБ, следовательно обращения к ней не будут долгими и колоритными.
  
  Требования к загрузке UI будут удовлетворены технологическим стеком, а именно jetpack Compose и его хорошо-проработанный Composer.
  Требования к отзывчивости UI будут выполнены, используя compose-функции LazyRow и LazyColumn.
  Требования к работе с данными будут выдержаны через ПАРТИЦИОНИРОВАНИЕ, оптимизацию запросов, а так же в виду малого объема данных для хранения (5 ГБ).

  </details>

- **Схема масштабирования сервиса при росте нагрузки в 10 раз:**

  <details>

  Что изменится при росте:
  - При росте x10 количество запросов будет до 30-35 в секунду.
  - Объем базы: вместо ~5 ГБ станет ~50 ГБ.
  - Трафик: ~5-6 Мб/c (для сравнения - обычный домашний интернет легко держит больше 50).
  
  Вывод: нагрузка все еще небольшая. Главное внимание к базе данных и обращениям к внешнему API расписаний.
  
  Архитектура при росте
  Сервер приложения
  - Сделать несколько копий (например 3-4) и поставить перед ними балансировщик, который будет распределять запросы между копиями.
  - Если нагрузка вырастает - автоматически поднимать больше копий. Если нагрузка падает - выключать лишние.
  
  Базы данных
  Большая часть запросов - это именно чтение расписаний. Поэтому необходимо:
  - Оставить одну базу данных для записей
  - Добавить реплики для чтения (1-2 штуки). Запросы на получение расписаний отправлять в реплики.
  - Использовать пул соединений, чтобы база данных не "захлебывалась" от множества коротких подключений.
  
  Кэширование
  - Хранить в кэше последние полученные расписания. При повторном запросе - брать данные из кэша.
  
  Взаимодействие с API
  - Делать запросы заранее ночью или за несколько часов до пар, чтобы данные уже были в базе.
  - Если API недоступно, то брать расписание из кэша и показывать пользователю последнюю версию.
  
  Как система будет работать при нагрузке
  1. Пользователь открывает приложение.
  2. Сервер проверяет кэш:
      - если данные есть - мгновенный ответ;
      - если нет - берёт из базы;
  3. Новые данные в фоне подгружаются и обновляют кэш и базу данных.
  
  Итог
  - Сервер: с 2 до 4 экземпляров, с возможностью автоматического увеличения при росте нагрузки.
  - База данных: добавить несколько реплик для чтения
  - Кэш: хранить расписания в памяти
  - Внешний API: данные подгружать заранее и кэшировать, чтобы не зависеть от задержек или ошибок

  </details>
